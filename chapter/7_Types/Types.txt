0. Iterable
    .1 What is Iterable?
    : Iterable과 다른 객체들을 구분 짓는 특징은 객체의 Symbol.iterator 속성에 특별한 함수가 들어있다는 것이다.
    만약 Symbol.iterator에 어떤 함수가 들어있다면  그 객체는 iterable이라 부르고, iterable protocol을 만족한다고 말한다.
    : 어떤 객체가 Iterable protocol을 만족한다면, next 메소드를 사용할 수 있어야 하고, next()는 value와 done을 프로퍼티로 갖는 객체를 반환해야 한다.
    : 어떤 객체가 iterable일 때 for ... of, spread 연산자, destructuring 등을 사용할 수 있다.

    .2 Generator
    : Iterable 객체를 반환하는 함수이다.
    : Iterable은 배열의 보다 일반적인 의미로, Array type을 포함하여 string, nodeList 등 유사 배열 객체 등을 포함하며,
    for ...of 문법을 사용할 수 있다는 특징이 있다.
    : return 대신 yield를 사용하여 data를 추가할 수 있다.
    : 일반적으로 개발자가 쓸 일은 많지 않다.

    .3 ex)
    // gen1, gen2는 Symbol.iterator 속성을 갖는다.
    // function* gen1() {}
    // const object = {
    //   *gen2() {}, // 메소드로 사용하기
    // };

    // generator는 다른 generator에 값을 넘겨줄 수 있다.
    // function* gen() {
    //   yield 1;
    //   yield "a";
    //   yield true;
    // }
    // for (const elem of gen()) {
    //   console.log(elem);
    // }
    
    // function* superGen() {
    //   yield* gen();
    //   yield* gen();
    // }
    // for (const elem of superGen()) {
    //   console.log(elem);
    // }
    
1. Symbol
    .1 What is Symbol?
    : For (1) Uniquness and (2) Privacy
    : new 연산자를 사용한 참조 객체 생성이 불가능하다. e.g. const myData = Symbol();
    : Symbol은 그 고유한 특성 때문에 주로 객체 프로퍼티의 key로서 사용된다. (프로퍼티 충돌을 방지)
    : for ...in 에서 key가 symbol인 프로퍼티들은 열거되지 않는다.
    : JSON.stringify() 호출에서도 symbol을 key로 갖는 프로퍼티들은 열거되지 않는다.

    // const someData = {};
    // const sym1 = Symbol("con");
    // const sym2 = Symbol("foo");
    // const sym3 = Symbol("bar");
    // someData.sym1 = "fk4l5$239$5gkr5YglaT)34332kf";
    // someData[sym2] = "45lgGttk24#$234%^rt5l6^56#5$#5f43!@";
    // someData[sym3] = "FG4232vvs@#43flaasd;2#$%402@35evdklDa";
    // console.log(someData);

    .2 Methods
        .0 Symbol()
        생성된 Symbol 객체는 고유하기는 하나 전역 Symbol 레지스트리에 저장되지는 않는다.

        .1 Symbol.for()
        여러 모듈들이 공유할 수 있는 Symbol key가 저장된 전역 Symbol 레지스트리에서 해당 문자열과 일치하는 Key 값을 갖는 Symbol을 반환한다.
        만약 없다면, 새로운 Symbol을 생성한다.
        // const sym1 = Symbol.for("foo");
        // const sym2 = Symbol.for("foo");
        // console.log(sym1===sym2);

        .2 Symbol.forKey()
        Symbol.for()과 달리 새로운 Symbol을 생성하지 않는다. 찾지 못하면 undefined를 반환한다.
        // const sym1 = Symbol();
        // const sym2 = Symbol.for("blur");
        // console.log(Symbol.keyFor(sym1));
        // console.log(Symbol.keyFor(sym2));

2. Set
    .1 What is Set?
    Value의 Uniquness를 보장하는 배열이다.

    .2 Methods
        .1 Set.add() & Set.delete() & Set.clear() & Set.forEach & Set.has()
        .2 Set.values() // Set.keys()의 별칭이다.
        .3 Set.entries()
        : Set에는 key 값이 없다. 그러나 map과 비슷한 기능을 유지하기 위해, value 값과 같은 key를 가진
        // const set = new Set([1, 2, 3, 4, 5]);
        // console.log(set.values()); // === console.log(set.keys())
        // const setIter = set.entries();
        // console.log(setIter.next().value);
        // console.log(setIter.next().value);
        // console.log(setIter.next().value);

3. WeakSet
    .1 What is WeakSet?
    : object만 받는다.
    : Garbage Collection으로 사용될 수 있다.
    : Set을 사용하자.

4. Map
    .1 What is Map?
    : key와 value 쌍을 갖고, 삽입 순서를 기억하는 객체이다.

    .2 Methods
        .1 Map.size
        
        .2 Map.set() & Map.delete() & Map.clear() & Map.get() & Map.has()
        : Map.has()는 key 유무를 반환한다.

        .3 Map.keys() & Map.values() & Map.forEach(value, key, map)

        .4 Map.entries()
        : [key, ,value] 쌍으로 이뤄진 새로운 iterator를 반환한다.
        // console.log(mapIter.next().value);


